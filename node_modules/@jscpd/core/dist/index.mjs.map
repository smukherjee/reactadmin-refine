{"version":3,"sources":["../src/validators/lines-length-clone.validator.ts","../src/validators/validator.ts","../src/rabin-karp.ts","../src/mode.ts","../src/detector.ts","../src/options.ts","../src/statistic.ts","../src/store/memory.ts"],"sourcesContent":["import {IClone, ICloneValidator, IOptions, IValidationResult} from '..';\n\nexport class LinesLengthCloneValidator implements ICloneValidator {\n\n\tvalidate(clone: IClone, options: IOptions): IValidationResult {\n\t\tconst lines = clone.duplicationA.end.line - clone.duplicationA.start.line;\n\t\tconst status = lines >= Number(options?.minLines);\n\n\t\treturn {\n\t\t\tstatus,\n\t\t\tmessage: status ? ['ok'] : [`Lines of code less than limit (${lines} < ${options.minLines})`],\n\t\t};\n\t}\n\n}\n","import {IClone, ICloneValidator, IOptions, IValidationResult} from '..';\n\nexport function runCloneValidators(clone: IClone, options: IOptions, validators: ICloneValidator[]): IValidationResult {\n\treturn validators.reduce((acc: IValidationResult, validator: ICloneValidator): IValidationResult => {\n\t\tconst res = validator.validate(clone, options);\n\t\treturn {\n\t\t\t...acc,\n\t\t\tstatus: res.status && acc.status,\n\t\t\tmessage: res.message ? [...(acc.message as any), ...res.message] : acc.message,\n\t\t};\n\n\t}, {status: true, message: [], clone})\n}\n","import {IClone, ICloneValidator, IMapFrame, IOptions, IStore, ITokenLocation, IValidationResult} from './interfaces';\nimport {runCloneValidators} from './validators';\nimport {ITokensMap} from '.';\nimport EventEmitter from \"eventemitter3\";\n\nexport class RabinKarp {\n  constructor(\n    private readonly options: IOptions,\n    private readonly eventEmitter: EventEmitter,\n    private readonly cloneValidators: ICloneValidator[],\n  ) {\n  }\n\n  public async run(tokenMap: ITokensMap, store: IStore<IMapFrame>): Promise<IClone[]> {\n    return new Promise((resolve => {\n      let mapFrameInStore: any;\n      let clone: IClone | null = null;\n\n      const clones: IClone[] = [];\n\n      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n      const loop = () => {\n        const iteration = tokenMap.next();\n\n\t\t\t\tstore\n\t\t\t\t\t.get(iteration.value.id)\n\t\t\t\t\t.then(\n\t\t\t\t\t\t(mapFrameFromStore: IMapFrame) => {\n\t\t\t\t\t\t\tmapFrameInStore = mapFrameFromStore;\n\t\t\t\t\t\t\tif (!clone) {\n                clone = RabinKarp.createClone(tokenMap.getFormat(), iteration.value, mapFrameInStore);\n              }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\tif (clone && this.validate(clone)) {\n\t\t\t\t\t\t\t\tclones.push(clone);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tclone = null;\n\t\t\t\t\t\t\tif (iteration.value.id) {\n\t\t\t\t\t\t\t\treturn store.set(iteration.value.id, iteration.value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n          )\n          .finally(() => {\n            if (!iteration.done) {\n              if (clone) {\n                // @ts-ignore\n                clone = RabinKarp.enlargeClone(clone, iteration.value, mapFrameInStore);\n              }\n              loop();\n            } else {\n              resolve(clones);\n            }\n          });\n      }\n      loop();\n    }));\n  }\n\n  private validate(clone: IClone): boolean {\n\n    const validation: IValidationResult = runCloneValidators(clone, this.options, this.cloneValidators);\n\n    if (validation.status) {\n      this.eventEmitter.emit('CLONE_FOUND', {clone})\n    } else {\n      this.eventEmitter.emit('CLONE_SKIPPED', {clone, validation})\n    }\n    return validation.status;\n  }\n\n  private static createClone(format: string, mapFrameA: IMapFrame, mapFrameB: IMapFrame): IClone {\n    return {\n      format,\n      foundDate: new Date().getTime(),\n      duplicationA: {\n        sourceId: mapFrameA.sourceId,\n        start: mapFrameA?.start?.loc?.start as ITokenLocation,\n        end: mapFrameA?.end?.loc?.end as ITokenLocation,\n        range: [mapFrameA.start.range[0], mapFrameA.end.range[1]],\n      },\n      duplicationB: {\n        sourceId: mapFrameB.sourceId,\n        start: mapFrameB?.start?.loc?.start as ITokenLocation,\n        end: mapFrameB?.end?.loc?.end as ITokenLocation,\n        range: [mapFrameB.start.range[0], mapFrameB.end.range[1]],\n      },\n    }\n  }\n\n  private static enlargeClone(clone: IClone, mapFrameA: IMapFrame, mapFrameB: IMapFrame): IClone {\n    clone.duplicationA.range[1] = mapFrameA.end.range[1];\n    clone.duplicationA.end = mapFrameA?.end?.loc?.end as ITokenLocation;\n    clone.duplicationB.range[1] = mapFrameB.end.range[1];\n    clone.duplicationB.end = mapFrameB?.end?.loc?.end as ITokenLocation;\n    return clone;\n  }\n\n}\n\n\n","import {IOptions, IToken} from './interfaces';\n\nexport type IMode = (token: IToken, options?: IOptions) => boolean;\n\nexport function strict(token: IToken): boolean {\n\treturn token.type !== 'ignore';\n}\n\nexport function mild(token: IToken): boolean {\n\treturn strict(token) && token.type !== 'empty' && token.type !== 'new_line';\n}\n\nexport function weak(token: IToken): boolean {\n  return mild(token)\n    && token.format !== 'comment'\n    && token.type !== 'comment'\n    && token.type !== 'block-comment';\n}\n\nconst MODES: { [name: string]: IMode } = {\n\tmild,\n\tstrict,\n\tweak,\n};\n\nexport function getModeByName(name: string): IMode {\n\tif (name in MODES) {\n\t\treturn MODES[name] as IMode;\n\t}\n\tthrow new Error(`Mode ${name} does not supported yet.`);\n}\n\nexport function getModeHandler(mode: string | IMode): IMode {\n\treturn typeof mode === 'string' ? getModeByName(mode) : mode;\n}\n","import {RabinKarp} from './rabin-karp';\nimport {IClone, ICloneValidator, IMapFrame, IOptions, IStore, ITokenizer, ITokensMap} from './interfaces';\nimport {LinesLengthCloneValidator} from './validators';\nimport {mild} from './mode';\nimport EventEmitter from \"eventemitter3\";\n// TODO replace to own event emitter\n\nexport type DetectorEvents = 'CLONE_FOUND' | 'CLONE_SKIPPED' | 'START_DETECTION';\n\nexport class Detector extends EventEmitter<DetectorEvents> {\n\n  private algorithm: RabinKarp;\n\n  constructor(\n    private readonly tokenizer: ITokenizer,\n    private readonly store: IStore<IMapFrame>,\n    private readonly cloneValidators: ICloneValidator[] = [],\n    private readonly options: IOptions) {\n    super();\n    this.initCloneValidators();\n    this.algorithm = new RabinKarp(this.options, this, this.cloneValidators);\n    this.options.minTokens = this.options.minTokens || 50;\n    this.options.maxLines = this.options.maxLines || 500;\n    this.options.minLines = this.options.minLines || 5;\n    this.options.mode = this.options.mode || mild;\n  }\n\n  public async detect(id: string, text: string, format: string): Promise<IClone[]> {\n    const tokenMaps: ITokensMap[] = this.tokenizer.generateMaps(id, text, format, this.options);\n    // TODO change stores implementation\n    this.store.namespace(format);\n\n    // @ts-ignore\n    const detect = async (tokenMap: ITokensMap, clones: IClone[]): Promise<IClone[]> => {\n      if (tokenMap) {\n        this.emit('START_DETECTION', {source: tokenMap});\n        return this.algorithm\n          .run(tokenMap, this.store)\n          .then((clns: IClone[]) => {\n            clones.push(...clns);\n            const nextTokenMap = tokenMaps.pop();\n            if (nextTokenMap) {\n              return detect(nextTokenMap, clones);\n            } else {\n              return clones;\n            }\n          });\n      }\n    }\n    const currentTokensMap = tokenMaps.pop()\n    return currentTokensMap ? detect(currentTokensMap, []) : [];\n  }\n\n  private initCloneValidators(): void {\n    if (this.options.minLines || this.options.maxLines) {\n      this.cloneValidators.push(new LinesLengthCloneValidator())\n    }\n  }\n}\n","import {IOptions, TOption} from './interfaces';\nimport {getModeHandler} from \"./mode\";\n\n\nexport function getDefaultOptions(): IOptions {\n  return {\n    executionId: new Date().toISOString(),\n    path: [process.cwd()],\n    mode: getModeHandler('mild'),\n    minLines: 5,\n    maxLines: 1000,\n    maxSize: '100kb',\n    minTokens: 50,\n    output: './report',\n    reporters: ['console'],\n    ignore: [],\n    threshold: undefined,\n    formatsExts: {},\n    debug: false,\n\t\tsilent: false,\n\t\tblame: false,\n\t\tcache: true,\n\t\tabsolute: false,\n\t\tnoSymlinks: false,\n\t\tskipLocal: false,\n\t\tignoreCase: false,\n\t\tgitignore: false,\n\t\treportersOptions: {},\n    exitCode: 0,\n\t};\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getOption(name: TOption, options?: IOptions): any {\n  const defaultOptions = getDefaultOptions();\n  return options ? options[name] || defaultOptions[name] : defaultOptions[name];\n}\n","// @ts-nocheck\nimport {DetectorEvents, IEventPayload, IHandler, IStatistic, IStatisticRow, ISubscriber} from '.';\n\nexport class Statistic implements ISubscriber {\n\tprivate static getDefaultStatistic(): IStatisticRow {\n\t\treturn {\n      lines: 0,\n      tokens: 0,\n      sources: 0,\n      clones: 0,\n      duplicatedLines: 0,\n      duplicatedTokens: 0,\n      percentage: 0,\n      percentageTokens: 0,\n      newDuplicatedLines: 0,\n      newClones: 0,\n    };\n\t}\n\n\tprivate statistic: IStatistic = {\n\t\tdetectionDate: new Date().toISOString(),\n\t\tformats: {},\n\t\ttotal: Statistic.getDefaultStatistic(),\n\t};\n\n\tpublic subscribe(): Partial<Record<DetectorEvents, IHandler>> {\n    return {\n      CLONE_FOUND: this.cloneFound.bind(this),\n      START_DETECTION: this.matchSource.bind(this),\n    }\n  }\n\n  public getStatistic(): IStatistic {\n    return this.statistic;\n  }\n\n  private cloneFound(payload: IEventPayload): void {\n    const {clone} = payload;\n    const id: string = clone.duplicationA.sourceId;\n    const id2: string = clone.duplicationB.sourceId;\n    const linesCount: number = clone.duplicationA.end.line - clone.duplicationA.start.line;\n    const duplicatedTokens: number = clone.duplicationA.end.position - clone.duplicationA.start.position;\n\n    this.statistic.total.clones++;\n    this.statistic.total.duplicatedLines += linesCount;\n    this.statistic.total.duplicatedTokens += duplicatedTokens;\n    this.statistic.formats[clone.format].total.clones++;\n    this.statistic.formats[clone.format].total.duplicatedLines += linesCount;\n    this.statistic.formats[clone.format].total.duplicatedTokens += duplicatedTokens;\n\n    this.statistic.formats[clone.format].sources[id].clones++;\n    this.statistic.formats[clone.format].sources[id].duplicatedLines += linesCount;\n    this.statistic.formats[clone.format].sources[id].duplicatedTokens += duplicatedTokens;\n\n    this.statistic.formats[clone.format].sources[id2].clones++;\n    this.statistic.formats[clone.format].sources[id2].duplicatedLines += linesCount;\n    this.statistic.formats[clone.format].sources[id2].duplicatedTokens += duplicatedTokens;\n\n    this.updatePercentage(clone.format);\n  }\n\n  private matchSource(payload: IEventPayload): void {\n    const {source} = payload;\n    const format = source.getFormat();\n    if (!(format in this.statistic.formats)) {\n      this.statistic.formats[format] = {\n        sources: {},\n        total: Statistic.getDefaultStatistic(),\n      };\n    }\n    this.statistic.total.sources++;\n    this.statistic.total.lines += source.getLinesCount();\n    this.statistic.total.tokens += source.getTokensCount();\n    this.statistic.formats[format].total.sources++;\n    this.statistic.formats[format].total.lines += source.getLinesCount();\n    this.statistic.formats[format].total.tokens += source.getTokensCount();\n\n    this.statistic.formats[format].sources[source.getId()] =\n      this.statistic.formats[format].sources[source.getId()] || Statistic.getDefaultStatistic();\n\n    this.statistic.formats[format].sources[source.getId()].sources = 1;\n    this.statistic.formats[format].sources[source.getId()].lines += source.getLinesCount();\n    this.statistic.formats[format].sources[source.getId()].tokens += source.getTokensCount();\n    this.updatePercentage(format);\n  }\n\n\tprivate updatePercentage(format: string): void {\n    this.statistic.total.percentage = Statistic.calculatePercentage(\n      this.statistic.total.lines,\n      this.statistic.total.duplicatedLines,\n    );\n    this.statistic.total.percentageTokens = Statistic.calculatePercentage(\n      this.statistic.total.tokens,\n      this.statistic.total.duplicatedTokens,\n    );\n\n    this.statistic.formats[format].total.percentage = Statistic.calculatePercentage(\n      this.statistic.formats[format].total.lines,\n      this.statistic.formats[format].total.duplicatedLines,\n    );\n    this.statistic.formats[format].total.percentageTokens = Statistic.calculatePercentage(\n      this.statistic.formats[format].total.tokens,\n      this.statistic.formats[format].total.duplicatedTokens,\n    );\n\n    Object.entries(this.statistic.formats[format].sources).forEach(([id, stat]) => {\n      this.statistic.formats[format].sources[id].percentage = Statistic.calculatePercentage(\n        stat.lines,\n        stat.duplicatedLines,\n      );\n      this.statistic.formats[format].sources[id].percentageTokens = Statistic.calculatePercentage(\n        stat.tokens,\n        stat.duplicatedTokens,\n      );\n    });\n  }\n\n  private static calculatePercentage(total: number, cloned: number): number {\n    return total ? Math.round((10000 * cloned) / total) / 100 : 0.0;\n  }\n}\n","import {IStore} from '..';\n\nexport class MemoryStore<IMapFrame> implements IStore<IMapFrame> {\n  private _namespace: string = '';\n\n  protected values: Record<string, Record<string, IMapFrame>> = {};\n\n  public namespace(namespace: string): void {\n    this._namespace = namespace;\n    this.values[namespace] = this.values[namespace] || {};\n  }\n\n  public get(key: string): Promise<IMapFrame> {\n    return new Promise((resolve, reject) => {\n      // @ts-ignore\n      if (key in this.values[this._namespace]) {\n        // @ts-ignore\n        resolve(this.values[this._namespace][key]);\n      } else {\n        reject(new Error('not found'));\n      }\n    });\n  }\n\n  public set(key: string, value: IMapFrame): Promise<IMapFrame> {\n    // @ts-ignore\n    this.values[this._namespace][key] = value;\n    return Promise.resolve(value);\n  }\n\n  close(): void {\n    this.values = {};\n  }\n}\n"],"mappings":"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","names":[]}